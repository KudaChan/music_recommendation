import { MoodAnalysis, Recommendation } from '@/app/types'; // Assuming types are updated
import { searchVideos } from '@/app/lib/youtube/client'; // Assuming searchVideos function exists
import { generateStructuredResponse } from '@/app/lib/gemini/client';

// Music recommendation agent
export async function getRecommendations(moodAnalysis: MoodAnalysis): Promise<Recommendation[]> {
    try {
        // Check if we should use Gemini for enhanced recommendations (now generates search terms)
        if (process.env.USE_GEMINI === 'true' && process.env.USE_YOUTUBE_API === 'true') {
            return await getEnhancedRecommendations(moodAnalysis);
        }

        // Check if we should use YouTube API directly with enhanced analysis (already improved)
        if (process.env.USE_YOUTUBE_API === 'true') {
            return await getYouTubeRecommendations(moodAnalysis);
        }

        // Fallback to mock recommendations
        return getMockRecommendations(moodAnalysis);
    } catch (error) {
        console.error('Music recommendation error:', error);
        // Return default recommendations as fallback
        return getDefaultRecommendations();
    }
}

// Get enhanced recommendations using Gemini to generate search terms and YouTube to find them
async function getEnhancedRecommendations(moodAnalysis: MoodAnalysis): Promise<Recommendation[]> {
    try {
        // Define the task for Gemini - NOW GENERATES SEARCH TERMS
        const task = `
Analyze the user's mood and music preferences based on the following analysis.
Your goal is to generate effective search queries for the YouTube Data API to find relevant music videos.
Consider the primary mood, mood keywords, suggested genres, extracted keywords, and era.
Generate 3-5 distinct search queries that are likely to return diverse and relevant music videos matching the analysis.
Focus on combinations of mood, genre, keywords, and era. Avoid requesting specific song titles unless they were explicitly extracted from the user's message.

Analysis:
Primary Mood: ${moodAnalysis.primaryMood}
Mood Keywords: ${moodAnalysis.moodKeywords}
Suggested Genres: ${moodAnalysis.suggestedGenres}
Extracted Keywords: ${moodAnalysis.extractedKeywords}
Era: ${moodAnalysis.era}
Confidence: ${moodAnalysis.confidence}

Provide the search queries in the following JSON format:
`;

        // Define the expected response format - NOW EXPECTING SEARCH QUERIES
        const format = {
            searchQueries: [
                "string (e.g., 'sad breakup songs pop', 'melancholy acoustic music', 'emotional ballads from 2020s')"
            ]
        };

        // Get search query suggestions from Gemini
        const response = await generateStructuredResponse(task, { analysis: moodAnalysis }, format);

        if (!response || !response.searchQueries || !Array.isArray(response.searchQueries) || response.searchQueries.length === 0) {
            console.warn('Invalid Gemini response for search queries:', response);
            // Fall back to direct YouTube recommendations with the enhanced analysis
            return await getYouTubeRecommendations(moodAnalysis);
        }

        // Use the generated search queries to find videos on YouTube
        const recommendations: Recommendation[] = [];
        const processedQueries = new Set<string>(); // Track queries to avoid duplicates

        for (const query of response.searchQueries) {
            // Avoid processing duplicate or empty queries
            if (!query || query.trim() === '' || processedQueries.has(query.trim().toLowerCase())) {
                continue;
            }
            processedQueries.add(query.trim().toLowerCase());

            try {
                // Search YouTube using the query generated by Gemini
                // Requesting a few more results per query to increase chances of finding valid ones
                // --- Pass options to searchVideos ---
                const results = await searchVideos(query, 3, { order: 'relevance' }); // Start with relevance
                // You could add logic here to try 'date' if 'relevance' yields no results or poor ones.
                // Example:
                // let results = await searchVideos(query, 3, { order: 'relevance' });
                // if (results.length === 0 && moodAnalysis.era !== 'current hits') { // Don't search by date for old eras
                //     results = await searchVideos(query, 3, { order: 'date' });
                // }
                // --- End Pass options ---


                // Add unique valid results to recommendations
                results.forEach(rec => {
                    // Check if we already have this song (basic check by youtubeId)
                    if (!recommendations.some(existingRec => existingRec.youtubeId === rec.youtubeId)) {
                        recommendations.push(rec);
                    }
                });

            } catch (error) {
                console.error(`Error searching YouTube with query "${query}":`, error);
                // Continue with the next query
                continue;
            }

            // If we have enough recommendations, stop
            if (recommendations.length >= 15) {
                break;
            }
        }

        // If we couldn't find enough songs, fall back to direct YouTube recommendations
        if (recommendations.length < 15) {
            console.warn(`Could not find ${15 - recommendations.length} recommendations from Gemini-generated queries. Falling back to direct YouTube search for remaining.`);
            const fallbackRecs = await getYouTubeRecommendations(moodAnalysis);
            // Combine found recommendations with fallback YouTube results, ensuring uniqueness and max 15
            fallbackRecs.forEach(rec => {
                if (!recommendations.some(existingRec => existingRec.youtubeId === rec.youtubeId)) {
                    recommendations.push(rec);
                }
            });
            return recommendations.slice(0, 15); // Ensure we don't exceed 15
        }


        return recommendations.slice(0, 15); // Return the top 15 unique recommendations
    } catch (error) {
        console.error('Enhanced recommendations error:', error);
        // Fall back to direct YouTube recommendations with the enhanced analysis
        return await getYouTubeRecommendations(moodAnalysis);
    }
}

// Get recommendations from YouTube API using enhanced analysis (This function remains largely the same,
// but now calls searchVideos with options)
async function getYouTubeRecommendations(moodAnalysis: MoodAnalysis): Promise<Recommendation[]> {
    try {
        // Construct a more dynamic search query using the enhanced analysis data
        // Prioritize extracted keywords, then suggested genres, then mood keywords, then primary mood
        const queryParts = [
            moodAnalysis.extractedKeywords,
            moodAnalysis.era, // Include era in the query
            moodAnalysis.suggestedGenres,
            moodAnalysis.moodKeywords,
            moodAnalysis.primaryMood !== 'neutral' ? `${moodAnalysis.primaryMood} music` : '' // Add mood music only if not neutral
        ].filter(part => part && part.trim() !== ''); // Filter out empty or whitespace parts

        // If no specific parts, use a default query
        const searchQuery = queryParts.length > 0 ? queryParts.join(' ') : 'popular music hits';

        console.log(`Searching YouTube with query: "${searchQuery}" (Direct Search)`);

        // Use our YouTube utility to search for videos
        // --- Pass options to searchVideos ---
        // For direct search, maybe prioritize relevance or viewCount, or try date if needed
        const recommendations = await searchVideos(searchQuery, 15, { order: 'relevance' });
        // Example: Try date if relevance yields nothing
        // if (recommendations.length === 0 && moodAnalysis.era !== 'current hits') {
        //     recommendations = await searchVideos(searchQuery, 5, { order: 'date' });
        // }
        // --- End Pass options ---


        // Return recommendations
        return recommendations;
    } catch (error) {
        console.error('YouTube API error:', error);
        // Fallback to mock recommendations
        return getMockRecommendations(moodAnalysis);
    }
}

// Get mock recommendations based on mood (fallback)
function getMockRecommendations(moodAnalysis: MoodAnalysis): Recommendation[] {
    // Mock recommendations based on mood
    const moodRecommendations: Record<string, Recommendation[]> = {
        happy: [
            { title: "Happy", artist: "Pharrell Williams", youtubeId: "ZbZSe6N_BXs" },
            { title: "Good Feeling", artist: "Flo Rida", youtubeId: "3OnnDqH6Wj8" },
            { title: "Can't Stop the Feeling", artist: "Justin Timberlake", youtubeId: "ru0K8uYEZWw" },
            { title: "Uptown Funk", artist: "Mark Ronson ft. Bruno Mars", youtubeId: "OPf0YbXqDm0" },
            { title: "Walking on Sunshine", artist: "Katrina & The Waves", youtubeId: "iPUmE-tne5U" }
        ],
        sad: [
            { title: "Someone Like You", artist: "Adele", youtubeId: "hLQl3WQQoQ0" },
            { title: "Fix You", artist: "Coldplay", youtubeId: "k4V3Mo61fJM" },
            { title: "Hurt", artist: "Johnny Cash", youtubeId: "8AHCfZTRGiI" },
            { title: "Say Something", artist: "A Great Big World", youtubeId: "VVgixOjGhVU" },
            { title: "Skinny Love", artist: "Bon Iver", youtubeId: "ssdgFoHLwnk" }
        ],
        energetic: [
            { title: "Eye of the Tiger", artist: "Survivor", youtubeId: "btPJPFnesV4" },
            { title: "Stronger", artist: "Kanye West", youtubeId: "PsO6ZnUZI0g" },
            { title: "Till I Collapse", artist: "Eminem", youtubeId: "gY9C0ItyO0o" },
            { title: "Thunderstruck", artist: "AC/DC", youtubeId: "v2AC41dglnM" },
            { title: "Don't Stop Me Now", artist: "Queen", youtubeId: "HgzGwKwLmgM" }
        ],
        relaxed: [
            { title: "Weightless", artist: "Marconi Union", youtubeId: "UfcAVejslrU" },
            { title: "Clair de Lune", artist: "Claude Debussy", youtubeId: "WNcsUNKlAKw" },
            { title: "Gymnopédie No.1", artist: "Erik Satie", youtubeId: "S-Xm7s9eGxU" },
            { title: "Watermark", artist: "Enya", youtubeId: "NO5tb20qQnA" },
            { title: "Breathe", artist: "Pink Floyd", youtubeId: "mrojrDCI02k" }
        ],
        angry: [
            { title: "Break Stuff", artist: "Limp Bizkit", youtubeId: "ZpUYjpKg9KY" },
            { title: "Bulls on Parade", artist: "Rage Against the Machine", youtubeId: "3L4YrGaR8E4" },
            { title: "Master of Puppets", artist: "Metallica", youtubeId: "0obBdrfUMzU" },
            { title: "Killing In The Name", artist: "Rage Against the Machine", youtubeId: "bWXazVhlyxQ" },
            { title: "Du Hast", artist: "Rammstein", youtubeId: "W3q8Od5qJio" }
        ],
        neutral: [
            { title: "Bohemian Rhapsody", artist: "Queen", youtubeId: "fJ9rUzIMcZQ" },
            { title: "Hotel California", artist: "Eagles", youtubeId: "BciS5krYL80" },
            { title: "Imagine", artist: "John Lennon", youtubeId: "VOgFZfRVaww" },
            { title: "Stairway to Heaven", artist: "Led Zeppelin", youtubeId: "QkF3oxziUI4" },
            { title: "Sweet Child O' Mine", artist: "Guns N' Roses", youtubeId: "1w7OgIMMRc4" }
        ]
    };

    // Get recommendations for the detected mood
    // NOTE: This fallback still uses the basic mood mapping.
    // Consider enhancing this or ensuring Gemini is enabled for better results.
    return moodRecommendations[moodAnalysis.primaryMood] || moodRecommendations.neutral;
}

// Default recommendations as fallback
function getDefaultRecommendations(): Recommendation[] {
    return [
        { title: "Bohemian Rhapsody", artist: "Queen", youtubeId: "fJ9rUzIMcZQ" },
        { title: "Hotel California", artist: "Eagles", youtubeId: "BciS5krYL80" },
        { title: "Imagine", artist: "John Lennon", youtubeId: "VOgFZfRVaww" },
        { title: "Stairway to Heaven", artist: "Led Zeppelin", youtubeId: "QkF3oxziUI4" },
        { title: "Sweet Child O' Mine", artist: "Guns N' Roses", youtubeId: "1w7OgIMMRc4" }
    ];
}
